// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/suyuan32/simple-admin-example-rpc/ent/student"
	"github.com/suyuan32/simple-admin-example-rpc/ent/teacher"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Limit uint64 `json:"limit"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

// Cursor of an edge type.
type Cursor struct {
	ID    uint64
	Value Value
}

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

type studentPager struct {
	order  *StudentOrder
	filter func(*StudentQuery) (*StudentQuery, error)
}

// StudentPaginateOption enables pagination customization.
type StudentPaginateOption func(*studentPager) error

// StudentOrder defines the ordering of Student.
type StudentOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *StudentOrderField `json:"field"`
}

// StudentOrderField defines the ordering field of Student.
type StudentOrderField struct {
	field    string
	toCursor func(*Student) Cursor
}

// DefaultStudentOrder is the default ordering of Student.
var DefaultStudentOrder = &StudentOrder{
	Direction: OrderDirectionAsc,
	Field: &StudentOrderField{
		field: student.FieldID,
		toCursor: func(s *Student) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

func newStudentPager(opts []StudentPaginateOption) (*studentPager, error) {
	pager := &studentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStudentOrder
	}
	return pager, nil
}

func (p *studentPager) applyFilter(query *StudentQuery) (*StudentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

// StudentPageList is Student PageList result.
type StudentPageList struct {
	List        []*Student   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (s *StudentQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...StudentPaginateOption,
) (*StudentPageList, error) {

	pager, err := newStudentPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	ret := &StudentPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := s.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	direction := pager.order.Direction
	s = s.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultStudentOrder.Field {
		s = s.Order(direction.orderFunc(DefaultStudentOrder.Field.field))
	}

	s = s.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type teacherPager struct {
	order  *TeacherOrder
	filter func(*TeacherQuery) (*TeacherQuery, error)
}

// TeacherPaginateOption enables pagination customization.
type TeacherPaginateOption func(*teacherPager) error

// TeacherOrder defines the ordering of Teacher.
type TeacherOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *TeacherOrderField `json:"field"`
}

// TeacherOrderField defines the ordering field of Teacher.
type TeacherOrderField struct {
	field    string
	toCursor func(*Teacher) Cursor
}

// DefaultTeacherOrder is the default ordering of Teacher.
var DefaultTeacherOrder = &TeacherOrder{
	Direction: OrderDirectionAsc,
	Field: &TeacherOrderField{
		field: teacher.FieldID,
		toCursor: func(t *Teacher) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

func newTeacherPager(opts []TeacherPaginateOption) (*teacherPager, error) {
	pager := &teacherPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTeacherOrder
	}
	return pager, nil
}

func (p *teacherPager) applyFilter(query *TeacherQuery) (*TeacherQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

// TeacherPageList is Teacher PageList result.
type TeacherPageList struct {
	List        []*Teacher   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (t *TeacherQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...TeacherPaginateOption,
) (*TeacherPageList, error) {

	pager, err := newTeacherPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	ret := &TeacherPageList{}

	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Limit: pageSize,
	}

	count, err := t.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	direction := pager.order.Direction
	t = t.Order(direction.orderFunc(pager.order.Field.field))
	if pager.order.Field != DefaultTeacherOrder.Field {
		t = t.Order(direction.orderFunc(DefaultTeacherOrder.Field.field))
	}

	t = t.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
